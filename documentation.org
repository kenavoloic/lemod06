#+TITLE:Documentation lemod06

* EDB
** Introduction :


Le monde de transport connaît une crise dans le recrutement des conducteurs poids lourds. 
Le recrutement d’un conducteur nécessite une évaluation sans faille, raison pour laquelle cette demande de construction d’une application a raison d’être.
Un chauffeur routier est responsable du transport de marchandises d'un endroit à un autre, tout en se conformant aux règles de sécurité routière et aux procédures de livraison. Il coordonne aussi les itinéraires de manière efficace.

L’entreprise souhaite que les entretiens des évaluations soient faits de manière factuelle en se basant sur des critères rationnels et objectifs.

Besoins:

L’entreprise exprime le besoin de réaliser une application qui traitera deux cas :

Cas 1 : évaluer un candidat conducteur de camion pour un nouveau recrutement,

Cas 2 : évaluer un conducteur salarié qui travaille déjà dans l'entreprise.


Pour le cas1: on trouve ci-dessous des éléments qui te permettront de rédiger un dossier de spécifications fonctionnelles et poser les critères des évaluations.

** Cas 1 : Recruter un nouveau Camionneur

Comment préparer la grille d'évaluation pour l'entretien d'embauche ?

Savoir-être attendus

Savoir-faire attendus

Questions de mise en situation

Exemple de grille d'évaluation d'entretien de recrutement

Les rubriques de la fiche d'entretien


Comment préparer la grille d'évaluation pour l'entretien d'embauche ?

Rédiger une grille d'entretien

L'entretien d'embauche est le moment crucial dans le processus de recrutement qui vise à déterminer si le candidat est le bon choix pour le poste vacant. Dans ce cadre, il importe d'évaluer plusieurs aspects de votre candidat. Tout d'abord, la vérification des compétences techniques est essentielle. Quelle que soit la profession, le postulant doit posséder les compétences et les connaissances requises pour remplir les tâches liées au poste. De plus, l'évaluation des soft skills, comme la capacité à travailler en équipe, la résilience, ou l'esprit de leadership est également nécessaire selon la nature de la fonction. Il est aussi primordial de comprendre les motivations du candidat et si son profil s'intégrera harmonieusement dans la culture d'entreprise. Dans la mesure du possible, essayez d'avoir une discussion ouverte et engageante, plutôt qu'un interrogatoire strict, pour mettre le candidat à l'aise et avoir une idée plus précise de sa personnalité.

La notation pour l'entretien d'embauche

Conduire un entretien d'embauche pour le poste de chauffeur de poids lourd demande la prise en compte de certaines particularités liées à ce métier.
Premièrement, la vérification des qualifications professionnelles et d'un permis de conduire valide est essentielle.
Il est aussi important de s'assurer de l'expérience du candidat en matière de conduite de véhicules lourds, de sa connaissance des règles de sécurité routière et de sa capacité à entretenir le véhicule.
Des questions situationnelles peuvent être posées pour évaluer comment le candidat réagit face à des situations d’urgence ou de stress.
Par ailleurs, l'évaluation de l’aptitude physique du candidat est une étape capitale étant donné les exigences physiques de ce travail.
Enfin, étant souvent amené à se déplacer sur de longues distances et à des horaires irréguliers, il est crucial de discuter de la disponibilité du candidat et de sa capacité à gérer le stress et l'isolement que peut parfois impliquer ce métier.

Savoir-être attendus
Pouvez-vous décrire une situation où vous avez dû faire preuve de prudence et d'attention tout en respectant les délais de livraison?

Le candidat décrit une situation dans laquelle il a fait preuve de discernement pour assurer la sécurité sur la route tout en respectant les délais.

Soft skills attendus

Comment le candidat évalue les situations de risque? Comment il gère les délais sous pression?
Avez-vous déjà fait face à une urgence ou à un imprévu pendant votre service? Comment avez-vous géré cela?
L'expérience du candidat avec les situations imprévues et sa capacité à gérer le stress et la résolution de problèmes en temps réel serait informative.

Soft skills attendus
Comment le candidat réagit sous pression? Quel était son réflexe en premier?

Comment maintenez-vous votre concentration pendant de longues heures de conduite?

Le candidat devrait expliquer les stratégies, méthodes ou habitudes qu'il utilise pour rester concentré et vigilant lors de longs trajets.

Soft skills attendus
Quelles sont les techniques de gestion de la fatigue du candidat?

Qu'est-ce qu'il fait pour prévenir les erreurs de conduite liées à la fatigue?

Comment établiriez-vous une bonne relation avec les clients et les collègues?

Le candidat devrait montrer qu'il est capable d'établir un respect et une compréhension mutuels, de communiquer efficacement et de gérer tout différend ou malentendu de manière professionnelle.
Soft skills attendus

Quels sont les principaux facteurs que le candidat considère pour une relation de travail saine et positive?

Comment gérez-vous la solitude et l'isolement inhérents au poste de chauffeur de poids lourd?

Le candidat devrait démontrer qu'il est capable de gérer de longues périodes de solitude et d'isolement et qu'il a des stratégies pour le faire.

Soft skills attendus
Quelles sont les activités que le candidat utilise pour gérer la solitude? 
Comment maintient-il sa motivation pendant ces moments?

Savoir-faire attendus
Avez-vous un permis de conduire de poids lourd valide et pouvez-vous fournir les détails de votre dossier de conduite?
Le candidat devrait confirmer qu'il possède bien un permis poids lourd valide et (dans le cadre légal) ne pas avoir d'infraction majeure à la conduite.
Hard skills à analyser
L'employeur cherchera à confirmer l'existence du permis et la propreté du dossier de conduite. Il faudra également vérifier la date d'expiration, vérifier les autorisations spécifiques (par exemple, la conduite de matériaux dangereux) et demander pour toute formation supplémentaire prise par le candidat.
Avez-vous de l'expérience avec l'entretien des poids lourds et leur maintenance basique ?
Le candidat peut citer des exemples précis de l'entretien de routine qu'il a effectué, comme le contrôle des fluides ou les vérifications pré-voyage.
Hard skills à analyser
L'employeur cherchera à savoir si le candidat est capable de maintenir le véhicule en bon état. Cela comprend à la fois des tâches d'entretien de routine et la capacité de déceler des problèmes éventuels avant qu'ils ne deviennent de gros problèmes.
Quelle est votre expérience avec les procédures de chargement et déchargement des marchandises à transporter?
Le candidat devrait être capable de parler des différents types de marchandises qu'il a manipulées et des procédures spécifiques pour les charger et les décharger en toute sécurité.
Hard skills à analyser

L'employeur cherchera à savoir si le candidat comprend les procédures de sécurité associées au chargement et au déchargement, ainsi que la manipulation de différents types de marchandises, par exemple des matériaux dangereux.
Pouvez-vous nous parler de votre expérience en conduite de nuit ou sur de longues distances?
Le candidat devrait avoir une expérience en conduite de nuit et sur de longues distances.
 Il devrait être en mesure de décrire comment planifier des arrêts pour le repos et comment il reste alerte pendant de longues périodes de conduite.
Hard skills à analyser
L'employeur cherchera à savoir si le candidat peut gérer la fatigue et maintenir des niveaux élevés de concentration sur de longues périodes. Il est également important de comprendre les limites légales sur les heures de conduite.
Le candidat devrait être en mesure de décrire des situations spécifiques où il a dû gérer une urgence ou un imprévu et expliquer comment il a géré la situation de manière sûre et efficace.
Hard skills à analyser
L'employeur cherchera à comprendre le jugement du candidat dans des situations stressantes, sa capacité à rester calme et à prendre des décisions rapides et responsables.


Questions de mise en situation
Vous êtes sur la route et un autre conducteur vous provoque et commence à conduire de manière imprudente autour de votre camion, comment réagissez-vous?
L'attitude la plus appropriée serait de rester calme, de ne pas répondre aux provocations, de maintenir une conduite sécuritaire et éventuellement d'aviser les autorités si la situation l'exige.
Compétences à évaluer
Ici, le but est de vérifier si le candidat sait agir avec professionnalisme même dans des situations stressantes. Il doit faire preuve de sang-froid et prioriser la sécurité.
Vous voyez que votre chargement est mal équilibré avant de partir, que faites-vous?
Le candidat doit indiquer qu'il ne prendra pas la route tant que le chargement n'est pas correctement équilibré. Il devrait contacter son supérieur ou l'équipe de chargement pour rectifier l'équilibre du chargement.
Compétences à évaluer
Le but ici est d'évaluer si le candidat est conscient des dangers d'un chargement mal équilibré et s'il sait à qui s'adresser dans ce cas.
Vous êtes en retard pour une livraison à cause d'un embouteillage imprévu, comment gérez-vous la situation?
Le candidat devrait exprimer qu'il communique immédiatement avec le client ou avec son supérieur pour l'informer du retard et présenter ses excuses.
Compétences à évaluer
La question vise à vérifier la gestion du stress du candidat, son respect des horaires et sa capacité à gérer des situations imprévues et à communiquer efficacement avec les clients.
Pendant que vous conduisez, vous remarquez que votre camion commence à se comporter de manière étrange et vous soupçonnez un problème mécanique. Que faites-vous?
Le candidat devrait indiquer qu'il arrête le camion dans un endroit sûr dès que possible et contacte son supérieur ou l'équipe de maintenance.
Compétences à évaluer
Le but est d'évaluer la capacité du candidat à reconnaître un problème potentiel et à prendre les mesures appropriées pour garantir sa sécurité et celle des autres.
Vous recevez une nouvelle commande avec des instructions spécifiques mais peu claires, comment réagissez-vous?
L'attitude la plus appropriée serait de ne pas supposer ou deviner. Le candidat doit demander des éclaircissements avant de commencer le travail.
Compétences à évaluer
Cette question met en évidence l'importance de la communication claire dans le rôle du chauffeur. Le candidat doit comprendre qu'il est préférable de demander des éclaircissements plutôt que de faire une erreur coûteuse.

** Cas2 : Evaluer un conducteur salarié de l’entreprise :

Voici les critères sur lesquels le conducteur salarié sera jugé en plus de certains critères intéressants  qui se trouvent dans le Cas 1 :

    • Respect des horaires (1-10/10)
    • Entretien du véhicule (1-10/10)
    • Communication (1-10/10)
    • Respect des horaires de travail (ODM) (1-10/10)
    • Remplissage des CMR (1-10/10)
    • Avis client (1-10/10)
    • Comportement interne (1-10/10)

Dans les deux cas Cas 1 et Cas 2 les évaluations selon le  rôle de chacun seront faites par:
    • Rh (Responsable ressources humaines) , 
    • Responsable de service, 
    • Responsable opérationnel
    • La direction

* prompt migration initiale
django. migration initiale avec données d'initialisation. crée moi une migration initiale avec des données d'initialisation.
Mon application se nomme 'suivi_conducteurs'.
crée moi une migration initiale avec des données d'initialisation. Trois site : Bordeaux, Arcachon, Libourne.
3 entreprises BDX Transport, Bassin Transport, Entre-Deux-Mers Transport. Ces trois entreprises sont basée respectivement à Bordeaux, Arcachon et Libourne. 3 services : 'Ressources Humaines','Exploitation' et 'Direction'. Chaque critère d'évaluation porte le nom d'une lettre de A à M. Les huit premiers sont actifs.
Trois types d'évaluation :         {
            'nom': 'Recrutement',
            'description': 'Évaluation des candidats avant leur embauche'
            'abreviation': 'rh1'
        },
        {
            'nom': 'Évaluation de conduite',
            'description': 'Évaluation des compétences de conduite en situation réelle'
            'abreviation': 'ex1'
        },
        {
            'nom': 'Évaluation comportementale',
            'description': "Évaluation du comportement du conducteur"
            'abreviation': 'ex2'
        },
Pour les critères        
Valeur minimale : 1
Valeur maximale : 10
Voici mon models.py

from django.db import models
from django.core.exceptions import ValidationError
from django.core.validators import RegexValidator

class Site(models.Model):
    """Site auquel est rattaché un conducteur"""
    nom_commune = models.CharField(max_length=255, verbose_name="Commune")
    code_postal = models.CharField(
            max_length = 5,
            verbose_name = "Code postal",
            validators = [
                RegexValidator(regex=r'^\d{5}$', message = "Un code postal est long de 5 caractères")
                ]
    )
    date_creation = models.DateTimeField(auto_now_add=True)

    def clean(self):
        super().clean()
        if self.nom_commune:
            self.nom_commune = self.nom_commune.strip()
        if self.code_postal:
            self.code_postal = self.code_postal.strip()
            if not self.code_postal.isdigit():
                raise ValidationError({'code_postal': 'Le code postal ne doit contenir que des chiffres'})
            if len(self.code_postal) != 5:
                raise ValidationError({'code_postal': 'Le code postal doit contenir exactement 5 chiffres'})

    class Meta:
        verbose_name = "Site"
        verbose_name_plural = "Sites"
        ordering = ['nom_commune']

    def __str__(self):
        return f"{self.nom_commune}"

class Societe(models.Model):
    """Société à laquelle un conducteur est rattaché"""
    socid = models.PositiveIntegerField(unique=True)
    socnom = models.CharField(max_length=255, verbose_name="Nom société")
    socactif = models.BooleanField(default=True, verbose_name="Active")
    soccode = models.CharField(max_length=255, verbose_name="Code société")
    soccp = models.CharField(
            max_length = 5,
            verbose_name = "Code postal",
            validators = [
                RegexValidator(regex=r'^\d{5}$', message = "Un code postal est long de 5 caractères")
                ]
    )
    socvillib1 = models.CharField(max_length=255, verbose_name="Ville")
    date_creation = models.DateTimeField(auto_now_add=True)

    def clean(self):
        if self.socnom:
            self.socnom = self.socnom.strip()
        if self.soccode:
            self.soccode = self.soccode.strip()
     
    class Meta:
        verbose_name = "Société"
        verbose_name_plural = "Sociétés"
        ordering = ['socnom']
        indexes = [models.Index(fields=['socnom']),]

    def __str__(self):
        return f"{self.socnom}"

class Service(models.Model):
    """Service auquel est rattaché l'évaluateur"""
    nom = models.CharField(max_length=255, verbose_name="Nom du service")
    abreviation = models.CharField(max_length=10, verbose_name="Abréviation")
    date_creation = models.DateTimeField(auto_now_add=True)

    def __str__(self):
        return f"{self.nom}"

    def clean(self):
        if self.nom:
            self.nom = self.nom.strip()
        if self.abreviation:
            self.abreviation = self.abreviation.strip()

    class Meta:
        verbose_name = "Service"
        verbose_name_plural = "Services"
        ordering = ['nom']
        
class Conducteur(models.Model):
    """Caractériques d'un conducteur"""
    salnom = models.CharField(max_length=255, verbose_name="nom")
    salnom2 = models.CharField(max_length=255, verbose_name="prénom")
    salsocid = models.ForeignKey(Societe, to_field='socid', on_delete=models.CASCADE, verbose_name="Société")
    salactif = models.BooleanField(default=True, verbose_name="Conducteur actif")
    site = models.ForeignKey(Site, on_delete=models.CASCADE, verbose_name="Site")
    interim_p = models.BooleanField(default=True, verbose_name="Intérim")
    sous_traitant_p = models.BooleanField(default=True, verbose_name="Sous-traitant")
    date_naissance = models.DateField(null=True, blank=True, verbose_name="Date de naissance")
    date_creation = models.DateTimeField(auto_now_add=True)

    def clean(self):
        if self.salnom:
            self.salnom = self.salnom.strip()
        if self.salnom2:
            self.salnom2 = self.salnom2.strip()
        
    def __str__(self):
        return f"{self.salnom}"

    @property
    def nom_complet(self):
        return f"{self.salnom} {self.salnom2}"

    class Meta:
        verbose_name = "Conducteur"
        verbose_name_plural = "Conducteurs"
        ordering = ['salnom','salnom2']

class Evaluateur(models.Model):
    """Utilisateur effectuant l'évaluation d'un conducteur"""
    nom = models.CharField(max_length=255, verbose_name="nom")
    prenom = models.CharField(max_length=255, verbose_name="prénom")
    service = models.ForeignKey(Service, on_delete=models.CASCADE, verbose_name="Service")

    def __str__(self):
            return f"{self.service.nom} {self.nom} {self.prenom}"

    @property
    def nom_complet(self):
        return f"{self.prenom} {self.nom}"

    def clean(self):
        if self.nom:
            self.nom = self.nom.strip()
        if self.prenom:
            self.prenom = self.prenom.strip()

    class Meta:
        verbose_name = "Évaluateur"
        verbose_name_plural = "Évaluateurs"
        ordering = ['nom', 'prenom']            
            

class TypologieEvaluation(models.Model):
    """ Types d'évaluation : avant le recrutement, évaluation de la conduite, évaluation du comportement"""
    nom = models.CharField(max_length=255, verbose_name="Nom")
    abreviation = models.CharField(max_length=10, verbose_name="Abréviation")
    description = models.TextField(verbose_name="Description")

    def __str__(self):
        return f"{self.nom}"

    class Meta:
        verbose_name="Type d'évaluation"
        verbose_name_plural = "Types d'évaluation"
    

class CritereEvaluation(models.Model):
    """Critères d'évaluation d'un conducteur"""
    nom = models.CharField(max_length=255)
    type_evaluation = models.ForeignKey(TypologieEvaluation, on_delete=models.CASCADE)
    valeur_mini = models.PositiveIntegerField()
    valeur_maxi = models.PositiveIntegerField()
    actif = models.BooleanField(default=True, help_text="Critère actuellement utilisé")
    date_creation = models.DateTimeField(auto_now_add=True)

    def __str__(self):
        return f"{self.nom} ({self.valeur_mini}-{self.valeur_maxi})"

    def clean(self):
        if self.nom:
            self.nom = self.nom.strip()
        if not self.nom:
            raise ValidationError({'nom': "Un nom de critère est requis."})
        if self.valeur_mini is not None and self.valeur_maxi is not None:
            if self.valeur_mini >= self.valeur_maxi:
                raise ValidationError('La valeur minimale doit être inférieure à la valeur maximale.')

    class Meta:
        verbose_name = "Critère d'évaluation"
        verbose_name_plural = "Critères d'évaluation"
        ordering = ['nom']

class Evaluation(models.Model):
    """Session de notation regroupant toutes les notes d'un conducteur par un évaluateur à une date donnée"""
    date_evaluation = models.DateField(verbose_name="Date d'évaluation")
    evaluateur = models.ForeignKey(Evaluateur, on_delete=models.CASCADE, verbose_name="Évaluateur")
    conducteur = models.ForeignKey(Conducteur, on_delete=models.CASCADE, verbose_name="Conducteur")
    type_evaluation = models.ForeignKey(TypologieEvaluation, on_delete=models.CASCADE, verbose_name="Type d'évaluation")
    date_creation = models.DateTimeField(auto_now_add=True)

    def __str__(self):
        return f"{self.date_evaluation} - {self.conducteur} par {self.evaluateur} ({self.type_evaluation})"

    def clean(self):
        if not self.date_evaluation:
            raise ValidationError({'date_evaluation': "Une date d'évaluation est requise."})
        
        # Validation : vérifier que toutes les notes correspondent au type d'évaluation
        if self.pk:  # Si l'objet existe déjà (modification)
            notes_incompatibles = self.notes.exclude(critere__type_evaluation=self.type_evaluation)
            if notes_incompatibles.exists():
                raise ValidationError({
                    'type_evaluation': "Impossible de changer le type d'évaluation : des notes existent déjà pour d'autres types."
                })

    class Meta:
        verbose_name = "Évaluation"
        verbose_name_plural = "Évaluations"
        unique_together = ['conducteur', 'date_evaluation', 'evaluateur', 'type_evaluation']
        ordering = ['-date_evaluation']
        indexes = [
            models.Index(fields=['date_evaluation']),
            models.Index(fields=['conducteur']),
            models.Index(fields=['type_evaluation']),
        ]
        
class Note(models.Model):
    """Note individuelle pour un critère spécifique dans une session d'évaluation"""
    evaluation = models.ForeignKey(Evaluation, on_delete=models.CASCADE, help_text="Session d'évaluation", related_name='notes')
    critere = models.ForeignKey(CritereEvaluation, on_delete=models.CASCADE, help_text="Critère évalué")
    valeur = models.PositiveIntegerField(null=True, blank=True, help_text="Note attribuée")
    date_creation = models.DateTimeField(auto_now_add=True)

    def __str__(self):
        return f"{self.evaluation.conducteur} - {self.critere.nom}: {self.valeur or 'Non noté'}"

    def clean(self):
        # Validation de la valeur selon les bornes du critère
        if self.valeur is not None:
            if self.valeur < self.critere.valeur_mini or self.valeur > self.critere.valeur_maxi:
                raise ValidationError({
                    'valeur': f'La note doit être comprise entre {self.critere.valeur_mini} et {self.critere.valeur_maxi}.'
                })
        
        # Validation de cohérence : le critère doit correspondre au type d'évaluation
        if self.evaluation_id and self.critere_id:
            if self.critere.type_evaluation != self.evaluation.type_evaluation:
                raise ValidationError({
                    'critere': f'Le critère doit correspondre au type d\'évaluation "{self.evaluation.type_evaluation}".'
                })

    @property
    def date_evaluation(self):
        return self.evaluation.date_evaluation

    @property
    def evaluateur(self):
        return self.evaluation.evaluateur

    @property
    def conducteur(self):
        return self.evaluation.conducteur

    @property
    def type_evaluation(self):
        return self.evaluation.type_evaluation  # Plus simple maintenant !
    
    class Meta:
        verbose_name = "Note"
        verbose_name_plural = "Notes"
        unique_together = ['evaluation', 'critere']
        ordering = ['critere__nom']
        indexes = [
            models.Index(fields=['evaluation', 'critere']),
        ]

* résultat :
#+begin_src python :results output

# Generated by Django migration
# Migration initiale avec données d'initialisation

from django.db import migrations, models
import django.db.models.deletion
import django.core.validators


def create_initial_data(apps, schema_editor):
    """Création des données d'initialisation"""
    
    # Récupération des modèles
    Site = apps.get_model('suivi_conducteurs', 'Site')
    Societe = apps.get_model('suivi_conducteurs', 'Societe')
    Service = apps.get_model('suivi_conducteurs', 'Service')
    TypologieEvaluation = apps.get_model('suivi_conducteurs', 'TypologieEvaluation')
    CritereEvaluation = apps.get_model('suivi_conducteurs', 'CritereEvaluation')
    
    # Création des sites
    sites_data = [
        {'nom_commune': 'Bordeaux', 'code_postal': '33000'},
        {'nom_commune': 'Arcachon', 'code_postal': '33120'},
        {'nom_commune': 'Libourne', 'code_postal': '33500'},
    ]
    
    sites = {}
    for site_data in sites_data:
        site = Site.objects.create(**site_data)
        sites[site.nom_commune] = site
    
    # Création des sociétés
    societes_data = [
        {
            'socid': 1,
            'socnom': 'BDX Transport',
            'socactif': True,
            'soccode': 'BDX001',
            'soccp': '33000',
            'socvillib1': 'Bordeaux'
        },
        {
            'socid': 2,
            'socnom': 'Bassin Transport',
            'socactif': True,
            'soccode': 'BSN001',
            'soccp': '33120',
            'socvillib1': 'Arcachon'
        },
        {
            'socid': 3,
            'socnom': 'Entre-Deux-Mers Transport',
            'socactif': True,
            'soccode': 'EDM001',
            'soccp': '33500',
            'socvillib1': 'Libourne'
        },
    ]
    
    for societe_data in societes_data:
        Societe.objects.create(**societe_data)
    
    # Création des services
    services_data = [
        {'nom': 'Ressources Humaines', 'abreviation': 'RH'},
        {'nom': 'Exploitation', 'abreviation': 'EXP'},
        {'nom': 'Direction', 'abreviation': 'DIR'},
    ]
    
    for service_data in services_data:
        Service.objects.create(**service_data)
    
    # Création des types d'évaluation
    types_evaluation_data = [
        {
            'nom': 'Recrutement',
            'description': 'Évaluation des candidats avant leur embauche',
            'abreviation': 'rh1'
        },
        {
            'nom': 'Évaluation de conduite',
            'description': 'Évaluation des compétences de conduite en situation réelle',
            'abreviation': 'ex1'
        },
        {
            'nom': 'Évaluation comportementale',
            'description': 'Évaluation du comportement du conducteur',
            'abreviation': 'ex2'
        },
    ]
    
    types_evaluation = {}
    for type_data in types_evaluation_data:
        type_eval = TypologieEvaluation.objects.create(**type_data)
        types_evaluation[type_data['nom']] = type_eval
    
    # Création des critères d'évaluation (A à M, les 8 premiers actifs)
    criteres_lettres = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M']
    
    # Pour chaque type d'évaluation, on crée les critères A à M
    for type_nom, type_eval in types_evaluation.items():
        for i, lettre in enumerate(criteres_lettres):
            # Les 8 premiers (A à H) sont actifs
            actif = i < 8
            
            CritereEvaluation.objects.create(
                nom=lettre,
                type_evaluation=type_eval,
                valeur_mini=0,
                valeur_maxi=20,  # Échelle sur 20 par défaut
                actif=actif
            )


def reverse_initial_data(apps, schema_editor):
    """Suppression des données d'initialisation en cas de rollback"""
    
    # Récupération des modèles
    Site = apps.get_model('suivi_conducteurs', 'Site')
    Societe = apps.get_model('suivi_conducteurs', 'Societe')
    Service = apps.get_model('suivi_conducteurs', 'Service')
    TypologieEvaluation = apps.get_model('suivi_conducteurs', 'TypologieEvaluation')
    CritereEvaluation = apps.get_model('suivi_conducteurs', 'CritereEvaluation')
    
    # Suppression dans l'ordre inverse des dépendances
    CritereEvaluation.objects.all().delete()
    TypologieEvaluation.objects.all().delete()
    Service.objects.all().delete()
    Societe.objects.all().delete()
    Site.objects.all().delete()


class Migration(migrations.Migration):

    initial = True

    dependencies = [
    ]

    operations = [
        # Création du modèle Site
        migrations.CreateModel(
            name='Site',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('nom_commune', models.CharField(max_length=255, verbose_name='Commune')),
                ('code_postal', models.CharField(max_length=5, validators=[django.core.validators.RegexValidator(message='Un code postal est long de 5 caractères', regex='^\\d{5}$')], verbose_name='Code postal')),
                ('date_creation', models.DateTimeField(auto_now_add=True)),
            ],
            options={
                'verbose_name': 'Site',
                'verbose_name_plural': 'Sites',
                'ordering': ['nom_commune'],
            },
        ),
        
        # Création du modèle Societe
        migrations.CreateModel(
            name='Societe',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('socid', models.PositiveIntegerField(unique=True)),
                ('socnom', models.CharField(max_length=255, verbose_name='Nom société')),
                ('socactif', models.BooleanField(default=True, verbose_name='Active')),
                ('soccode', models.CharField(max_length=255, verbose_name='Code société')),
                ('soccp', models.CharField(max_length=5, validators=[django.core.validators.RegexValidator(message='Un code postal est long de 5 caractères', regex='^\\d{5}$')], verbose_name='Code postal')),
                ('socvillib1', models.CharField(max_length=255, verbose_name='Ville')),
                ('date_creation', models.DateTimeField(auto_now_add=True)),
            ],
            options={
                'verbose_name': 'Société',
                'verbose_name_plural': 'Sociétés',
                'ordering': ['socnom'],
                'indexes': [models.Index(fields=['socnom'], name='suivi_conducteurs_societe_socnom_idx')],
            },
        ),
        
        # Création du modèle Service
        migrations.CreateModel(
            name='Service',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('nom', models.CharField(max_length=255, verbose_name='Nom du service')),
                ('abreviation', models.CharField(max_length=10, verbose_name='Abréviation')),
                ('date_creation', models.DateTimeField(auto_now_add=True)),
            ],
            options={
                'verbose_name': 'Service',
                'verbose_name_plural': 'Services',
                'ordering': ['nom'],
            },
        ),
        
        # Création du modèle TypologieEvaluation
        migrations.CreateModel(
            name='TypologieEvaluation',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('nom', models.CharField(max_length=255, verbose_name='Nom')),
                ('abreviation', models.CharField(max_length=10, verbose_name='Abréviation')),
                ('description', models.TextField(verbose_name='Description')),
            ],
            options={
                'verbose_name': "Type d'évaluation",
                'verbose_name_plural': "Types d'évaluation",
            },
        ),
        
        # Création du modèle Conducteur
        migrations.CreateModel(
            name='Conducteur',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('salnom', models.CharField(max_length=255, verbose_name='nom')),
                ('salnom2', models.CharField(max_length=255, verbose_name='prénom')),
                ('salactif', models.BooleanField(default=True, verbose_name='Conducteur actif')),
                ('interim_p', models.BooleanField(default=True, verbose_name='Intérim')),
                ('sous_traitant_p', models.BooleanField(default=True, verbose_name='Sous-traitant')),
                ('date_naissance', models.DateField(blank=True, null=True, verbose_name='Date de naissance')),
                ('date_creation', models.DateTimeField(auto_now_add=True)),
                ('salsocid', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='suivi_conducteurs.societe', to_field='socid', verbose_name='Société')),
                ('site', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='suivi_conducteurs.site', verbose_name='Site')),
            ],
            options={
                'verbose_name': 'Conducteur',
                'verbose_name_plural': 'Conducteurs',
                'ordering': ['salnom', 'salnom2'],
            },
        ),
        
        # Création du modèle Evaluateur
        migrations.CreateModel(
            name='Evaluateur',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('nom', models.CharField(max_length=255, verbose_name='nom')),
                ('prenom', models.CharField(max_length=255, verbose_name='prénom')),
                ('service', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='suivi_conducteurs.service', verbose_name='Service')),
            ],
            options={
                'verbose_name': 'Évaluateur',
                'verbose_name_plural': 'Évaluateurs',
                'ordering': ['nom', 'prenom'],
            },
        ),
        
        # Création du modèle CritereEvaluation
        migrations.CreateModel(
            name='CritereEvaluation',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('nom', models.CharField(max_length=255)),
                ('valeur_mini', models.PositiveIntegerField()),
                ('valeur_maxi', models.PositiveIntegerField()),
                ('actif', models.BooleanField(default=True, help_text='Critère actuellement utilisé')),
                ('date_creation', models.DateTimeField(auto_now_add=True)),
                ('type_evaluation', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='suivi_conducteurs.typologieevaluation')),
            ],
            options={
                'verbose_name': "Critère d'évaluation",
                'verbose_name_plural': "Critères d'évaluation",
                'ordering': ['nom'],
            },
        ),
        
        # Création du modèle Evaluation
        migrations.CreateModel(
            name='Evaluation',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('date_evaluation', models.DateField(verbose_name="Date d'évaluation")),
                ('date_creation', models.DateTimeField(auto_now_add=True)),
                ('conducteur', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='suivi_conducteurs.conducteur', verbose_name='Conducteur')),
                ('evaluateur', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='suivi_conducteurs.evaluateur', verbose_name='Évaluateur')),
                ('type_evaluation', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='suivi_conducteurs.typologieevaluation', verbose_name="Type d'évaluation")),
            ],
            options={
                'verbose_name': 'Évaluation',
                'verbose_name_plural': 'Évaluations',
                'ordering': ['-date_evaluation'],
                'indexes': [
                    models.Index(fields=['date_evaluation'], name='suivi_conducteurs_evaluation_date_idx'),
                    models.Index(fields=['conducteur'], name='suivi_conducteurs_evaluation_conducteur_idx'),
                    models.Index(fields=['type_evaluation'], name='suivi_conducteurs_evaluation_type_idx'),
                ],
            },
        ),
        
        # Création du modèle Note
        migrations.CreateModel(
            name='Note',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('valeur', models.PositiveIntegerField(blank=True, help_text='Note attribuée', null=True)),
                ('date_creation', models.DateTimeField(auto_now_add=True)),
                ('critere', models.ForeignKey(help_text='Critère évalué', on_delete=django.db.models.deletion.CASCADE, to='suivi_conducteurs.critereevaluation')),
                ('evaluation', models.ForeignKey(help_text="Session d'évaluation", on_delete=django.db.models.deletion.CASCADE, related_name='notes', to='suivi_conducteurs.evaluation')),
            ],
            options={
                'verbose_name': 'Note',
                'verbose_name_plural': 'Notes',
                'ordering': ['critere__nom'],
                'indexes': [
                    models.Index(fields=['evaluation', 'critere'], name='suivi_conducteurs_note_eval_critere_idx'),
                ],
            },
        ),
        
        # Ajout des contraintes d'unicité
        migrations.AddConstraint(
            model_name='evaluation',
            constraint=models.UniqueConstraint(fields=('conducteur', 'date_evaluation', 'evaluateur', 'type_evaluation'), name='unique_evaluation'),
        ),
        migrations.AddConstraint(
            model_name='note',
            constraint=models.UniqueConstraint(fields=('evaluation', 'critere'), name='unique_note_evaluation_critere'),
        ),
        
        # Migration de données pour créer les données d'initialisation
        migrations.RunPython(
            create_initial_data,
            reverse_initial_data,
        ),
    ]
#+end_src

* résultat 3
#+begin_src python :results output

# Generated by Django migration
# Migration initiale avec données d'initialisation

from django.db import migrations, models
import django.db.models.deletion
import django.core.validators


def create_initial_data(apps, schema_editor):
    """Création des données d'initialisation"""
    from datetime import date
    
    # Récupération des modèles
    Site = apps.get_model('suivi_conducteurs', 'Site')
    Societe = apps.get_model('suivi_conducteurs', 'Societe')
    Service = apps.get_model('suivi_conducteurs', 'Service')
    TypologieEvaluation = apps.get_model('suivi_conducteurs', 'TypologieEvaluation')
    CritereEvaluation = apps.get_model('suivi_conducteurs', 'CritereEvaluation')
    Conducteur = apps.get_model('suivi_conducteurs', 'Conducteur')
    
    # Création des sites
    sites_data = [
        {'nom_commune': 'Bordeaux', 'code_postal': '33000'},
        {'nom_commune': 'Arcachon', 'code_postal': '33120'},
        {'nom_commune': 'Libourne', 'code_postal': '33500'},
    ]
    
    sites = {}
    for site_data in sites_data:
        site = Site.objects.create(**site_data)
        sites[site.nom_commune] = site
    
    # Création des sociétés
    societes_data = [
        {
            'socid': 1,
            'socnom': 'BDX Transport',
            'socactif': True,
            'soccode': 'BDX001',
            'soccp': '33000',
            'socvillib1': 'Bordeaux'
        },
        {
            'socid': 2,
            'socnom': 'Bassin Transport',
            'socactif': True,
            'soccode': 'BSN001',
            'soccp': '33120',
            'socvillib1': 'Arcachon'
        },
        {
            'socid': 3,
            'socnom': 'Entre-Deux-Mers Transport',
            'socactif': True,
            'soccode': 'EDM001',
            'soccp': '33500',
            'socvillib1': 'Libourne'
        },
    ]
    
    societes = {}
    for societe_data in societes_data:
        societe = Societe.objects.create(**societe_data)
        societes[societe.socid] = societe
    
    # Création des services
    services_data = [
        {'nom': 'Ressources Humaines', 'abreviation': 'RH'},
        {'nom': 'Exploitation', 'abreviation': 'EXP'},
        {'nom': 'Direction', 'abreviation': 'DIR'},
    ]
    
    for service_data in services_data:
        Service.objects.create(**service_data)
    
    # Création des types d'évaluation
    types_evaluation_data = [
        {
            'nom': 'Recrutement',
            'description': 'Évaluation des candidats avant leur embauche',
            'abreviation': 'rh1'
        },
        {
            'nom': 'Évaluation de conduite',
            'description': 'Évaluation des compétences de conduite en situation réelle',
            'abreviation': 'ex1'
        },
        {
            'nom': 'Évaluation comportementale',
            'description': 'Évaluation du comportement du conducteur',
            'abreviation': 'ex2'
        },
    ]
    
    types_evaluation = {}
    for type_data in types_evaluation_data:
        type_eval = TypologieEvaluation.objects.create(**type_data)
        types_evaluation[type_data['nom']] = type_eval
    
    # Création des critères d'évaluation (A à M, avec différents nombres actifs selon le type)
    criteres_lettres = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M']
    
    # Définition des critères actifs par type d'évaluation
    criteres_actifs_par_type = {
        'Recrutement': 10,  # A à J (10 critères actifs)
        'Évaluation de conduite': 8,  # A à H (8 critères actifs)
        'Évaluation comportementale': 7,  # A à G (7 critères actifs)
    }
    
    # Pour chaque type d'évaluation, on crée les critères A à M
    for type_nom, type_eval in types_evaluation.items():
        nb_actifs = criteres_actifs_par_type[type_nom]
        
        for i, lettre in enumerate(criteres_lettres):
            # Actif selon le nombre défini pour chaque type
            actif = i < nb_actifs
            
            CritereEvaluation.objects.create(
                nom=lettre,
                type_evaluation=type_eval,
                valeur_mini=1,
                valeur_maxi=10,  # Échelle de 1 à 10
                actif=actif
            )
    
    # Création des conducteurs - 10 par société
    conducteurs_data = {
        1: [  # BDX Transport - Bordeaux
            {'salnom': 'Martin', 'salnom2': 'Pierre', 'date_naissance': date(1985, 3, 15), 'interim_p': False, 'sous_traitant_p': False},
            {'salnom': 'Dubois', 'salnom2': 'Jean', 'date_naissance': date(1978, 7, 22), 'interim_p': False, 'sous_traitant_p': False},
            {'salnom': 'Bernard', 'salnom2': 'Michel', 'date_naissance': date(1982, 11, 8), 'interim_p': False, 'sous_traitant_p': False},
            {'salnom': 'Petit', 'salnom2': 'Alain', 'date_naissance': date(1990, 1, 12), 'interim_p': True, 'sous_traitant_p': False},
            {'salnom': 'Robert', 'salnom2': 'François', 'date_naissance': date(1975, 9, 30), 'interim_p': False, 'sous_traitant_p': False},
            {'salnom': 'Richard', 'salnom2': 'Philippe', 'date_naissance': date(1988, 5, 18), 'interim_p': False, 'sous_traitant_p': True},
            {'salnom': 'Durand', 'salnom2': 'Antoine', 'date_naissance': date(1983, 12, 4), 'interim_p': False, 'sous_traitant_p': False},
            {'salnom': 'Moreau', 'salnom2': 'Stéphane', 'date_naissance': date(1987, 6, 25), 'interim_p': True, 'sous_traitant_p': False},
            {'salnom': 'Simon', 'salnom2': 'Christophe', 'date_naissance': date(1981, 4, 14), 'interim_p': False, 'sous_traitant_p': False},
            {'salnom': 'Laurent', 'salnom2': 'Thierry', 'date_naissance': date(1979, 10, 7), 'interim_p': False, 'sous_traitant_p': True},
        ],
        2: [  # Bassin Transport - Arcachon
            {'salnom': 'Garcia', 'salnom2': 'Carlos', 'date_naissance': date(1986, 2, 20), 'interim_p': False, 'sous_traitant_p': False},
            {'salnom': 'Rodriguez', 'salnom2': 'Manuel', 'date_naissance': date(1984, 8, 16), 'interim_p': False, 'sous_traitant_p': False},
            {'salnom': 'Martinez', 'salnom2': 'José', 'date_naissance': date(1977, 12, 28), 'interim_p': False, 'sous_traitant_p': False},
            {'salnom': 'Lopez', 'salnom2': 'Miguel', 'date_naissance': date(1991, 3, 9), 'interim_p': True, 'sous_traitant_p': False},
            {'salnom': 'Gonzalez', 'salnom2': 'Diego', 'date_naissance': date(1989, 7, 13), 'interim_p': False, 'sous_traitant_p': False},
            {'salnom': 'Wilson', 'salnom2': 'David', 'date_naissance': date(1980, 11, 22), 'interim_p': False, 'sous_traitant_p': True},
            {'salnom': 'Anderson', 'salnom2': 'James', 'date_naissance': date(1985, 1, 17), 'interim_p': False, 'sous_traitant_p': False},
            {'salnom': 'Taylor', 'salnom2': 'Robert', 'date_naissance': date(1976, 9, 5), 'interim_p': False, 'sous_traitant_p': False},
            {'salnom': 'Brown', 'salnom2': 'Michael', 'date_naissance': date(1992, 4, 11), 'interim_p': True, 'sous_traitant_p': False},
            {'salnom': 'Davis', 'salnom2': 'William', 'date_naissance': date(1983, 6, 27), 'interim_p': False, 'sous_traitant_p': True},
        ],
        3: [  # Entre-Deux-Mers Transport - Libourne
            {'salnom': 'Leroy', 'salnom2': 'Pascal', 'date_naissance': date(1974, 5, 3), 'interim_p': False, 'sous_traitant_p': False},
            {'salnom': 'Roux', 'salnom2': 'Frédéric', 'date_naissance': date(1987, 9, 19), 'interim_p': False, 'sous_traitant_p': False},
            {'salnom': 'Vincent', 'salnom2': 'Olivier', 'date_naissance': date(1981, 2, 26), 'interim_p': False, 'sous_traitant_p': False},
            {'salnom': 'Fournier', 'salnom2': 'Yves', 'date_naissance': date(1990, 12, 1), 'interim_p': True, 'sous_traitant_p': False},
            {'salnom': 'Girard', 'salnom2': 'Patrice', 'date_naissance': date(1978, 8, 24), 'interim_p': False, 'sous_traitant_p': False},
            {'salnom': 'Bonnet', 'salnom2': 'Gérard', 'date_naissance': date(1985, 4, 6), 'interim_p': False, 'sous_traitant_p': True},
            {'salnom': 'Dupont', 'salnom2': 'Serge', 'date_naissance': date(1982, 10, 15), 'interim_p': False, 'sous_traitant_p': False},
            {'salnom': 'Lambert', 'salnom2': 'Bruno', 'date_naissance': date(1988, 6, 8), 'interim_p': True, 'sous_traitant_p': False},
            {'salnom': 'Fontaine', 'salnom2': 'Claude', 'date_naissance': date(1979, 1, 21), 'interim_p': False, 'sous_traitant_p': False},
            {'salnom': 'Rousseau', 'salnom2': 'Éric', 'date_naissance': date(1986, 11, 12), 'interim_p': False, 'sous_traitant_p': True},
        ]
    }
    
    # Mapping des sociétés vers leurs sites
    societe_site_mapping = {
        1: sites['Bordeaux'],    # BDX Transport -> Bordeaux
        2: sites['Arcachon'],    # Bassin Transport -> Arcachon
        3: sites['Libourne'],    # Entre-Deux-Mers Transport -> Libourne
    }
    
    # Création des conducteurs
    for socid, conducteurs_list in conducteurs_data.items():
        societe = societes[socid]
        site = societe_site_mapping[socid]
        
        for conducteur_data in conducteurs_list:
            Conducteur.objects.create(
                salnom=conducteur_data['salnom'],
                salnom2=conducteur_data['salnom2'],
                salsocid=societe,
                site=site,
                date_naissance=conducteur_data['date_naissance'],
                interim_p=conducteur_data['interim_p'],
                sous_traitant_p=conducteur_data['sous_traitant_p'],
                salactif=True  # Tous actifs par défaut
            )


def reverse_initial_data(apps, schema_editor):
    """Suppression des données d'initialisation en cas de rollback"""
    
    # Récupération des modèles
    Site = apps.get_model('suivi_conducteurs', 'Site')
    Societe = apps.get_model('suivi_conducteurs', 'Societe')
    Service = apps.get_model('suivi_conducteurs', 'Service')
    TypologieEvaluation = apps.get_model('suivi_conducteurs', 'TypologieEvaluation')
    CritereEvaluation = apps.get_model('suivi_conducteurs', 'CritereEvaluation')
    Conducteur = apps.get_model('suivi_conducteurs', 'Conducteur')
    
    # Suppression dans l'ordre inverse des dépendances
    Conducteur.objects.all().delete()
    CritereEvaluation.objects.all().delete()
    TypologieEvaluation.objects.all().delete()
    Service.objects.all().delete()
    Societe.objects.all().delete()
    Site.objects.all().delete()


class Migration(migrations.Migration):

    initial = True

    dependencies = [
    ]

    operations = [
        # Création du modèle Site
        migrations.CreateModel(
            name='Site',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('nom_commune', models.CharField(max_length=255, verbose_name='Commune')),
                ('code_postal', models.CharField(max_length=5, validators=[django.core.validators.RegexValidator(message='Un code postal est long de 5 caractères', regex='^\\d{5}$')], verbose_name='Code postal')),
                ('date_creation', models.DateTimeField(auto_now_add=True)),
            ],
            options={
                'verbose_name': 'Site',
                'verbose_name_plural': 'Sites',
                'ordering': ['nom_commune'],
            },
        ),
        
        # Création du modèle Societe
        migrations.CreateModel(
            name='Societe',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('socid', models.PositiveIntegerField(unique=True)),
                ('socnom', models.CharField(max_length=255, verbose_name='Nom société')),
                ('socactif', models.BooleanField(default=True, verbose_name='Active')),
                ('soccode', models.CharField(max_length=255, verbose_name='Code société')),
                ('soccp', models.CharField(max_length=5, validators=[django.core.validators.RegexValidator(message='Un code postal est long de 5 caractères', regex='^\\d{5}$')], verbose_name='Code postal')),
                ('socvillib1', models.CharField(max_length=255, verbose_name='Ville')),
                ('date_creation', models.DateTimeField(auto_now_add=True)),
            ],
            options={
                'verbose_name': 'Société',
                'verbose_name_plural': 'Sociétés',
                'ordering': ['socnom'],
                'indexes': [models.Index(fields=['socnom'], name='suivi_conducteurs_societe_socnom_idx')],
            },
        ),
        
        # Création du modèle Service
        migrations.CreateModel(
            name='Service',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('nom', models.CharField(max_length=255, verbose_name='Nom du service')),
                ('abreviation', models.CharField(max_length=10, verbose_name='Abréviation')),
                ('date_creation', models.DateTimeField(auto_now_add=True)),
            ],
            options={
                'verbose_name': 'Service',
                'verbose_name_plural': 'Services',
                'ordering': ['nom'],
            },
        ),
        
        # Création du modèle TypologieEvaluation
        migrations.CreateModel(
            name='TypologieEvaluation',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('nom', models.CharField(max_length=255, verbose_name='Nom')),
                ('abreviation', models.CharField(max_length=10, verbose_name='Abréviation')),
                ('description', models.TextField(verbose_name='Description')),
            ],
            options={
                'verbose_name': "Type d'évaluation",
                'verbose_name_plural': "Types d'évaluation",
            },
        ),
        
        # Création du modèle Conducteur
        migrations.CreateModel(
            name='Conducteur',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('salnom', models.CharField(max_length=255, verbose_name='nom')),
                ('salnom2', models.CharField(max_length=255, verbose_name='prénom')),
                ('salactif', models.BooleanField(default=True, verbose_name='Conducteur actif')),
                ('interim_p', models.BooleanField(default=True, verbose_name='Intérim')),
                ('sous_traitant_p', models.BooleanField(default=True, verbose_name='Sous-traitant')),
                ('date_naissance', models.DateField(blank=True, null=True, verbose_name='Date de naissance')),
                ('date_creation', models.DateTimeField(auto_now_add=True)),
                ('salsocid', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='suivi_conducteurs.societe', to_field='socid', verbose_name='Société')),
                ('site', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='suivi_conducteurs.site', verbose_name='Site')),
            ],
            options={
                'verbose_name': 'Conducteur',
                'verbose_name_plural': 'Conducteurs',
                'ordering': ['salnom', 'salnom2'],
            },
        ),
        
        # Création du modèle Evaluateur
        migrations.CreateModel(
            name='Evaluateur',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('nom', models.CharField(max_length=255, verbose_name='nom')),
                ('prenom', models.CharField(max_length=255, verbose_name='prénom')),
                ('service', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='suivi_conducteurs.service', verbose_name='Service')),
            ],
            options={
                'verbose_name': 'Évaluateur',
                'verbose_name_plural': 'Évaluateurs',
                'ordering': ['nom', 'prenom'],
            },
        ),
        
        # Création du modèle CritereEvaluation
        migrations.CreateModel(
            name='CritereEvaluation',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('nom', models.CharField(max_length=255)),
                ('valeur_mini', models.PositiveIntegerField()),
                ('valeur_maxi', models.PositiveIntegerField()),
                ('actif', models.BooleanField(default=True, help_text='Critère actuellement utilisé')),
                ('date_creation', models.DateTimeField(auto_now_add=True)),
                ('type_evaluation', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='suivi_conducteurs.typologieevaluation')),
            ],
            options={
                'verbose_name': "Critère d'évaluation",
                'verbose_name_plural': "Critères d'évaluation",
                'ordering': ['nom'],
            },
        ),
        
        # Création du modèle Evaluation
        migrations.CreateModel(
            name='Evaluation',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('date_evaluation', models.DateField(verbose_name="Date d'évaluation")),
                ('date_creation', models.DateTimeField(auto_now_add=True)),
                ('conducteur', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='suivi_conducteurs.conducteur', verbose_name='Conducteur')),
                ('evaluateur', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='suivi_conducteurs.evaluateur', verbose_name='Évaluateur')),
                ('type_evaluation', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='suivi_conducteurs.typologieevaluation', verbose_name="Type d'évaluation")),
            ],
            options={
                'verbose_name': 'Évaluation',
                'verbose_name_plural': 'Évaluations',
                'ordering': ['-date_evaluation'],
                'indexes': [
                    models.Index(fields=['date_evaluation'], name='suivi_conducteurs_evaluation_date_idx'),
                    models.Index(fields=['conducteur'], name='suivi_conducteurs_evaluation_conducteur_idx'),
                    models.Index(fields=['type_evaluation'], name='suivi_conducteurs_evaluation_type_idx'),
                ],
            },
        ),
        
        # Création du modèle Note
        migrations.CreateModel(
            name='Note',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('valeur', models.PositiveIntegerField(blank=True, help_text='Note attribuée', null=True)),
                ('date_creation', models.DateTimeField(auto_now_add=True)),
                ('critere', models.ForeignKey(help_text='Critère évalué', on_delete=django.db.models.deletion.CASCADE, to='suivi_conducteurs.critereevaluation')),
                ('evaluation', models.ForeignKey(help_text="Session d'évaluation", on_delete=django.db.models.deletion.CASCADE, related_name='notes', to='suivi_conducteurs.evaluation')),
            ],
            options={
                'verbose_name': 'Note',
                'verbose_name_plural': 'Notes',
                'ordering': ['critere__nom'],
                'indexes': [
                    models.Index(fields=['evaluation', 'critere'], name='suivi_conducteurs_note_eval_critere_idx'),
                ],
            },
        ),
        
        # Ajout des contraintes d'unicité
        migrations.AddConstraint(
            model_name='evaluation',
            constraint=models.UniqueConstraint(fields=('conducteur', 'date_evaluation', 'evaluateur', 'type_evaluation'), name='unique_evaluation'),
        ),
        migrations.AddConstraint(
            model_name='note',
            constraint=models.UniqueConstraint(fields=('evaluation', 'critere'), name='unique_note_evaluation_critere'),
        ),
        
        # Migration de données pour créer les données d'initialisation
        migrations.RunPython(
            create_initial_data,
            reverse_initial_data,
        ),
    ]
#+end_src
